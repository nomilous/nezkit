// Generated by CoffeeScript 1.4.0
var GitSeed, SEED_VERSION, fs, nodefn, sequence;

fs = require('fs');

sequence = require('when/sequence');

nodefn = require('when/node/function');

SEED_VERSION = 2;

GitSeed = (function() {

  GitSeed.init = function(superTask, root, Plugin) {
    return Plugin.Package.search(superTask, root, Plugin, function(error, packages) {
      var tree;
      tree = new GitSeed(superTask, root, Plugin, packages);
      return tree.save();
    });
  };

  function GitSeed(superTask, root, Plugin, array) {
    var repo, _i, _len;
    this.superTask = superTask;
    this.root = root;
    this.Plugin = Plugin;
    if (typeof this.superTask.resolve !== 'function' || typeof this.superTask.reject !== 'function' || typeof this.superTask.notify.info.normal !== 'function') {
      throw new Error("" + this.constructor.name + " requires superTask");
    }
    this.control = "" + this.root + "/.git-seed";
    if (array instanceof Array) {
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        repo = array[_i];
        if (repo.root) {
          repo.version = 'ROOT_REPO_REF';
        }
      }
      this.array = array;
    } else if (typeof array === 'undefined') {
      this.array = this.load(Plugin);
    }
  }

  GitSeed.prototype.save = function() {
    try {
      fs.writeFileSync(this.control, JSON.stringify({
        version: SEED_VERSION,
        repos: this.array
      }, null, 2));
      return this.superTask.notify.event.good('seed update', {
        description: "wrote file: " + this.control,
        seed: this.array
      });
    } catch (error) {
      this.superTask.notify.info.bad('seed update failed', error.toString());
      throw error;
    }
  };

  GitSeed.prototype.load = function(Plugin) {
    var array, json, newFormat, properties, repo, repos, _i, _j, _len, _len1;
    try {
      if (!fs.lstatSync(this.control).isFile()) {
        throw '';
      }
    } catch (error) {
      throw "expected control file: " + this.control;
    }
    try {
      json = JSON.parse(fs.readFileSync(this.control));
      array = [];
      if (typeof json.version === 'undefined') {
        console.log("\nOld .git-seed file detected!\n\nupdating to new format...\n");
        this.array = [];
        repos = [];
        for (_i = 0, _len = json.length; _i < _len; _i++) {
          repo = json[_i];
          newFormat = {
            root: repo.root,
            workDir: repo.path,
            packageManager: repo.manager,
            'remote.origin.url': repo.origin,
            'HEAD': repo.branch,
            'version': repo.ref
          };
          this.array.push(newFormat);
          repos.push(newFormat);
        }
        this.save();
        console.log("\nIMPORTANT\n---------\n\nbefore commiting the new .git-seed file consider that\nother members of your team may still be using an older\ngit-seed version\n\nthe first version cannot handle unexpected format\n\nIT WILL BLOW UP \n");
      } else {
        repos = json.repos;
      }
      this.array = [];
      for (_j = 0, _len1 = repos.length; _j < _len1; _j++) {
        properties = repos[_j];
        array.push(new Plugin.Package(properties));
      }
      return array;
    } catch (error) {
      throw "error loading control file: " + this.control + " " + (error.toString());
    }
  };

  GitSeed.prototype.status = function(callback) {
    return GitSeed.action(this.superTask, 'status', {}, this.Plugin.Package, this.array, callback);
  };

  GitSeed.prototype.commit = function(message, callback) {
    return GitSeed.action(this.superTask, 'commit', {
      message: message
    }, this.Plugin.Package, this.array, callback);
  };

  GitSeed.prototype.clone = function(callback) {
    var _this = this;
    return sequence([
      function() {
        return nodefn.call(GitSeed.action, _this.superTask, 'clone', {}, _this.Plugin.Package, _this.array);
      }, function() {
        return nodefn.call(GitSeed.action, _this.superTask, 'install', {}, _this.Plugin.Package, _this.array);
      }
    ]).then(function(results) {
      if (callback) {
        return callback(null, results);
      }
    }, function(error) {
      if (callback) {
        return callback(error);
      }
    });
  };

  GitSeed.prototype.pull = function(first, callback) {
    var targets;
    if (first) {
      targets = [this.array[0]];
    } else {
      targets = this.array.slice(1);
    }
    return nodefn.call(GitSeed.action, this.superTask, 'pull', {}, this.Plugin.Package, targets).then(function(result) {
      if (callback) {
        return callback(null, result);
      }
    }, function(error) {
      if (callback) {
        return callback(error);
      }
    });
  };

  GitSeed.action = function(superTask, action, args, Repo, repoArray, callback) {
    var event, fail, info, repo, succeed, targs;
    event = superTask.notify.event;
    info = superTask.notify.info;
    succeed = function(results) {
      switch (action) {
        case 'clone':
        case 'install':
          event.good("seed " + action, 'success');
          break;
        default:
          info.good("seed " + action, 'success');
      }
      info.good("seed " + action + " results", {
        results: results
      });
      return callback(null, results);
    };
    fail = function(error) {
      switch (action) {
        case 'clone':
        case 'install':
          event.bad("seed " + action, 'failed');
          break;
        default:
          info.bad("seed " + action, 'failed');
      }
      info.bad("seed " + action + " error", {
        error: error
      });
      return callback(error);
    };
    targs = [];
    return sequence((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = repoArray.length; _i < _len; _i++) {
        repo = repoArray[_i];
        targs.unshift(repo);
        _results.push(function() {
          return nodefn.call(Repo[action], superTask, targs.pop(), args);
        });
      }
      return _results;
    })()).then(succeed, fail);
  };

  return GitSeed;

})();

module.exports = GitSeed;
